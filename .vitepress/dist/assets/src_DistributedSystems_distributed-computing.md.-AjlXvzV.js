import{_ as e,o as t,c as a,R as o}from"./chunks/framework.OwEraUkW.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"src/DistributedSystems/distributed-computing.md","filePath":"src/DistributedSystems/distributed-computing.md"}'),i={name:"src/DistributedSystems/distributed-computing.md"},r=o('<p>the computing itself is a task that can be done using just one computer, but what if the task that is going to be done jut by one by one computer is a task that is too heavy and can be a time and resource costly task ? what if i said we can divide the task between the multiple computers and then run the task? you might say how ?</p><h2 id="distributed-computing" tabindex="-1">distributed computing <a class="header-anchor" href="#distributed-computing" aria-label="Permalink to &quot;distributed computing&quot;">​</a></h2><p>the distributed computing is when we divide the a heavy task between multiple computers, this is done multiple ways such as prallelelazing the computations for the task that can be parallelized or using the crowd sourcing(folding at home)</p><h3 id="prallelization" tabindex="-1">prallelization <a class="header-anchor" href="#prallelization" aria-label="Permalink to &quot;prallelization&quot;">​</a></h3><p>is about a task that can be divided into multiple smaller tasks which can be computed independently and then we can use the final result of each small task to reach the goal task.</p><p>the recon that we can not just speed up a single processor is heat, the electron speed moving around the processor is too high that will melt the processor.</p><h3 id="crowd-sourcing-folding-at-home" tabindex="-1">crowd sourcing(folding at home) <a class="header-anchor" href="#crowd-sourcing-folding-at-home" aria-label="Permalink to &quot;crowd sourcing(folding at home)&quot;">​</a></h3><p>this approach is similar to what the software layer of the blockchains are operating with, meaning that you can install a copy of the running program on your computer and then participate in the network and get selected by the associated mechanism to compute a task for the network.</p><h3 id="cpu-and-the-cores" tabindex="-1">cpu and the cores <a class="header-anchor" href="#cpu-and-the-cores" aria-label="Permalink to &quot;cpu and the cores&quot;">​</a></h3><p>if our cpu has only 4 cores, this means that we can only operate only 4 operations at the exact same time in this cpu.</p><p>the giga hertz is the speed of the core of your cpu that can operate based of of that.</p><h3 id="threads" tabindex="-1">threads <a class="header-anchor" href="#threads" aria-label="Permalink to &quot;threads&quot;">​</a></h3><p>the threads are essential a batch of the operations gathered together and they all are in a queue of a single core.</p><h3 id="threading" tabindex="-1">threading <a class="header-anchor" href="#threading" aria-label="Permalink to &quot;threading&quot;">​</a></h3><p>the core deciding to which thread must be ran and calculated is the threading. threading is not operating on multiple cores , its about switching between those cores</p><h3 id="concurrent-programming" tabindex="-1">concurrent programming <a class="header-anchor" href="#concurrent-programming" aria-label="Permalink to &quot;concurrent programming&quot;">​</a></h3><p>the switch operation between the threads by a single core is called concurrent programming, when a thread is having a operation that doesn&#39;t need to get executed in this exact moment, the core will switch on another thread and does the calculations of that thread while waiting for other sleeping thread.</p><p>the operation of waiting and sleeping of a thread is called <code>hanging</code>.</p>',18),n=[r];function s(h,c,d,l,p,u){return t(),a("div",null,n)}const b=e(i,[["render",s]]);export{g as __pageData,b as default};
