# Algorithms

An algorithm is a the complete steps to perform in order to solve a problem.

in the following content you will see the common and famous algorithm based on the different categories:

1. **Problem-Solving Strategies**
    - **Brute Force:** Exhaustively exploring all possibilities, simple but inefficient.
    - **Divide-and-Conquer:** Breaking down a problem into smaller sub-problems, efficient for specific problems.
        - **Example:** Merge Sort algorithm divides and sorts sub-arrays for efficient overall sorting.
    - **Greedy:** Making locally optimal choices to reach a global solution, fast but not always optimal.
        - **Example:** Dijkstra's algorithm greedily chooses shortest edges to find the shortest path in a graph.
    - **Dynamic Programming:** Storing solutions to sub-problems for future reuse, efficient for overlapping sub-problems.
        - **Example:** Optimal coin change problem uses dynamic programming to find the minimum number of coins needed for a given amount.

2. **Searching Algorithms**
    - **Linear Search:** Sequential traversal until the target is found, slow for large datasets.
    - **Binary Search:** Efficiently dividing the search space based on sorted data, faster for sorted arrays.
    - **Hashing:** Using a mathematical function to map data to unique keys for fast retrieval (efficient for specific data types).

3. **Sorting Algorithms**
    - **Bubble Sort:** Repeatedly swapping adjacent elements until sorted, simple but slow.
    - **Merge Sort:** Divide-and-conquer approach, merging sorted sub-arrays, efficient for large datasets.
    - **Quick Sort:** Partitioning data around a pivot element for efficient sorting, fast but randomized.

4. **Graph Algorithms**
    - **Breadth-First Search (BFS):** Explores all nodes at a given level before moving to the next, efficient for shortest path finding.
    - **Depth-First Search (DFS):** Explores a branch as deep as possible before backtracking, efficient for finding connected components.
